<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slides - Cursos de Docker y Kubernetes</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .controls button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .controls button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }

        .slide-counter {
            color: #fff;
            font-size: 14px;
            padding: 0 10px;
            font-weight: 500;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            z-index: 1000;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .back-button:hover {
            background: rgba(102, 126, 234, 0.9);
            transform: translateX(-3px);
        }

        #slides-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .slide {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 80px;
            box-sizing: border-box;
            position: absolute;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateX(100px);
            overflow-y: auto;
        }

        .slide.active {
            opacity: 1;
            transform: translateX(0);
            z-index: 1;
        }

        .slide.prev {
            transform: translateX(-100px);
        }

        .slide h1 {
            font-size: 3.5em;
            margin-bottom: 30px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .slide h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-align: center;
            color: #667eea;
        }

        .slide h3 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #764ba2;
        }

        .slide p {
            font-size: 1.6em;
            line-height: 1.8;
            margin-bottom: 20px;
            text-align: center;
            max-width: 900px;
        }

        .slide ul, .slide ol {
            font-size: 1.4em;
            line-height: 2;
            margin: 20px 0;
            max-width: 800px;
        }

        .slide li {
            margin-bottom: 15px;
        }

        .slide code {
            background: rgba(102, 126, 234, 0.2);
            padding: 3px 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #a8b5ff;
        }

        .slide pre {
            background: rgba(0, 0, 0, 0.8) !important;
            padding: 25px;
            border-radius: 10px;
            overflow-x: auto;
            font-size: 1.1em;
            margin: 20px 0;
            border: 1px solid rgba(102, 126, 234, 0.3);
            max-width: 1000px;
            width: 100%;
        }

        .slide pre code {
            background: none !important;
            padding: 0;
            color: #fff;
            font-family: 'Courier New', 'Monaco', 'Consolas', monospace;
        }

        /* Estilos para Prism.js */
        .slide pre[class*="language-"] {
            background: rgba(0, 0, 0, 0.8) !important;
        }

        .slide code[class*="language-"] {
            background: rgba(0, 0, 0, 0.8) !important;
        }

        .slide table {
            width: 100%;
            max-width: 900px;
            border-collapse: collapse;
            margin: 30px 0;
        }

        .slide table th,
        .slide table td {
            padding: 15px 20px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .slide table th {
            background: rgba(102, 126, 234, 0.3);
            font-weight: 600;
        }

        .slide table tr:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .slide img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            margin: 20px auto;
            display: block;
        }
        
        /* Im√°genes peque√±as (emojis) en l√≠nea con el texto */
        .slide li img,
        .slide p img {
            display: inline !important;
            vertical-align: middle !important;
            max-width: 1.2em !important;
            max-height: 1.2em !important;
            width: auto !important;
            height: auto !important;
            margin: 0 0.2em !important;
            padding: 0 !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        
        /* Mantener im√°genes grandes como bloque */
        .slide img[style*="max-width: 100"],
        .slide img[style*="width: 100"] {
            display: block !important;
            max-width: 100% !important;
            margin: 20px auto !important;
        }

        /* Limitar tama√±o de iconos emoji y texto en slides */
        .slide {
            font-size: 1.2em !important;
        }
        
        /* Controlar tama√±o de emojis e iconos */
        .slide :is(h1, h2, h3, h4, h5, h6, p, li, strong, em, span, div) {
            font-size: inherit !important;
        }
        
        /* Limitar tama√±o espec√≠fico de emojis */
        .slide :is(h1, h2, h3, h4, h5, h6, p, li, strong, em, span, div)::before,
        .slide :is(h1, h2, h3, h4, h5, h6, p, li, strong, em, span, div)::after {
            font-size: 1em !important;
        }
        
        /* Tama√±os espec√≠ficos para t√≠tulos */
        .slide h1 {
            font-size: 2em !important;
            line-height: 1.2 !important;
        }
        
        .slide h2 {
            font-size: 1.6em !important;
            line-height: 1.3 !important;
        }
        
        .slide h3 {
            font-size: 1.3em !important;
            line-height: 1.4 !important;
        }
        
        .slide p, .slide li {
            font-size: 1em !important;
            line-height: 1.6 !important;
        }
        
        /* Limitar tama√±o de emojis en listas y p√°rrafos */
        .slide ul li::marker,
        .slide ol li::marker {
            font-size: 1em !important;
        }
        
        /* Limitar tama√±o de elementos que contienen emojis */
        .slide section {
            font-size: inherit !important;
        }
        
        /* Asegurar que los emojis en el HTML compilado de Marp no sean grandes */
        .slide section * {
            font-size: inherit !important;
        }
        
        .slide section h1 {
            font-size: 2em !important;
        }
        
        .slide section h2 {
            font-size: 1.6em !important;
        }
        
        .slide section h3 {
            font-size: 1.3em !important;
        }
        
        .slide section p,
        .slide section li {
            font-size: 1em !important;
        }

        .slide blockquote {
            border-left: 4px solid #667eea;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #ccc;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 1.5em;
        }

        .error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            gap: 20px;
            text-align: center;
            padding: 40px;
        }

        .error h1 {
            color: #ff6b6b;
        }

        /* Estilos para emojis en l√≠nea con el texto */
        .emoji {
            font-size: 1em !important;
            display: inline !important;
            vertical-align: middle !important;
            line-height: 1 !important;
        }
        
        /* Emojis dentro de listas y p√°rrafos alineados con el texto */
        .slide li img,
        .slide li .emoji,
        .slide p img:not([style*="max-width: 100"]) {
            vertical-align: baseline !important;
            margin-right: 0.3em !important;
        }
        @media (max-width: 768px) {
            .slide {
                padding: 40px 20px;
            }

            .slide h1 {
                font-size: 2em;
            }

            .slide h2 {
                font-size: 1.8em;
            }

            .slide p, .slide li {
                font-size: 1.2em;
            }

            .controls {
                flex-wrap: wrap;
                padding: 10px 15px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button" id="backButton">‚Üê Volver</a>
    
    <div id="slides-container">
        <div class="loading">Cargando slides...</div>
    </div>

    <div class="controls">
        <button id="prevBtn" onclick="previousSlide()">‚Üê Anterior</button>
        <span class="slide-counter">
            <span id="currentSlide">1</span> / <span id="totalSlides">1</span>
        </span>
        <button id="nextBtn" onclick="nextSlide()">Siguiente ‚Üí</button>
        <button onclick="toggleFullscreen()">‚õ∂ Pantalla Completa</button>
    </div>

    <script>
        let currentSlideIndex = 0;
        let slides = [];

        // Obtener el m√≥dulo de la URL
        const urlParams = new URLSearchParams(window.location.search);
        let module = urlParams.get('module') || 'docker/01-primer-contenedor';
        
        // Actualizar bot√≥n "Volver" seg√∫n el curso
        const backButton = document.getElementById('backButton');
        if (module.startsWith('kubernetes/')) {
            backButton.href = 'index-kubernetes.html';
        } else {
            backButton.href = 'index.html';
        }

        // Configurar marked para renderizar markdown
        marked.setOptions({
            breaks: true,
            gfm: true,
            highlight: function(code, lang) {
                // Preservar el lenguaje para Prism.js
                if (lang && Prism.languages[lang]) {
                    return Prism.highlight(code, Prism.languages[lang], lang);
                }
                return code;
            },
            langPrefix: 'language-',
        });

        // Detectar si estamos en protocolo file:// (no soportado por CORS)
        function isFileProtocol() {
            return window.location.protocol === 'file:';
        }

        // Funci√≥n para cargar slides (intenta HTML primero, luego MD)
        function loadSlides() {
            // Verificar si estamos usando file:// protocol
            if (isFileProtocol()) {
                const errorBackUrl = module.startsWith('kubernetes/') ? 'index-kubernetes.html' : 'index.html';
                const container = document.getElementById('slides-container');
                container.innerHTML = `
                    <div class="error">
                        <h1>‚ö†Ô∏è Error de CORS</h1>
                        <p style="font-size: 1.2em; margin-bottom: 30px;">
                            No se pueden cargar archivos usando el protocolo <code>file://</code>
                        </p>
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 20px; border-radius: 10px; max-width: 600px; text-align: left; margin: 20px 0;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üìã Soluci√≥n: Usa un servidor HTTP local</h3>
                            <p style="margin-bottom: 15px;">Ejecuta uno de estos comandos en la terminal:</p>
                            <pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 5px; overflow-x: auto; margin: 10px 0;"><code style="color: #a8b5ff;"># Desde la ra√≠z del proyecto:
npm run serve

# O si est√°s en la carpeta dist:
cd dist && npx http-server -p 8000 --cors</code></pre>
                            <p style="margin-top: 15px; font-size: 0.9em; color: #aaa;">
                                Luego abre: <code style="color: #667eea;">http://localhost:8000/viewer.html?module=${module}</code>
                            </p>
                        </div>
                        <a href="${errorBackUrl}" class="back-button" style="margin-top: 20px;">Volver al inicio</a>
                    </div>
                `;
                throw new Error('CORS: Se requiere servidor HTTP local');
            }

            const cacheBuster = urlParams.get('dev') === 'true' ? `?t=${Date.now()}` : '';
            
            // Intentar cargar slides.html primero (modo build/producci√≥n)
            return fetch(`${module}/slides.html${cacheBuster}`, { cache: 'no-store' })
                .then(response => {
                    if (response.ok) {
                        return response.text().then(html => ({ type: 'html', content: html }));
                    }
                    // Si no existe HTML, intentar con MD (modo desarrollo)
                    return fetch(`${module}/slides.md${cacheBuster}`, { cache: 'no-store' })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('No se encontraron slides para este m√≥dulo');
                            }
                            return response.text().then(md => ({ type: 'md', content: md }));
                        });
                });
        }

        // Cargar el archivo de slides
        loadSlides()
            .then(({ type, content }) => {
                let slidesToProcess = [];
                
                if (type === 'html') {
                    // Parsear HTML generado por Marp
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');
                    const sections = doc.querySelectorAll('section');
                    
                    if (sections.length > 0) {
                        // Si hay secciones (formato Marp HTML), procesarlas
                        sections.forEach(section => {
                            // Limpiar estilos inline que puedan hacer los iconos grandes
                            const allElements = section.querySelectorAll('*');
                            allElements.forEach(el => {
                                // Remover estilos inline de font-size grandes en elementos con emojis
                                if (el.style.fontSize && parseFloat(el.style.fontSize) > 2) {
                                    el.style.fontSize = '';
                                }
                                // Asegurar que los emojis no sean excesivamente grandes
                                if (el.textContent && /[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u.test(el.textContent)) {
                                    el.style.fontSize = el.style.fontSize || '1em';
                                }
                            });
                            slidesToProcess.push(section.outerHTML);
                        });
                    } else {
                        // Si no hay secciones, intentar extraer del body
                        const bodyContent = doc.body.innerHTML;
                        // Dividir por separadores de slide si existen
                        slidesToProcess = bodyContent.split(/<hr\s*\/?>/i).filter(s => s.trim());
                    }
                } else {
                    // Procesar Markdown (modo desarrollo)
                    const slideContent = content.split(/^---$/m).filter(s => s.trim());
                    
                    // Filtrar el frontmatter si existe
                    if (slideContent[0] && slideContent[0].includes('marp:')) {
                        slidesToProcess = slideContent.slice(1);
                    } else {
                        slidesToProcess = slideContent;
                    }
                }

                const container = document.getElementById('slides-container');
                container.innerHTML = '';

                // Crear slides
                slidesToProcess.forEach((content, index) => {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'slide';
                    slideDiv.id = `slide-${index}`;
                    
                    // Si es HTML, insertar directamente; si es MD, convertir a HTML
                    if (type === 'html') {
                        // El contenido HTML ya viene procesado de Marp
                        slideDiv.innerHTML = content;
                        
                        // Aplicar estilos adicionales despu√©s de insertar el HTML
                        setTimeout(() => {
                            const allElements = slideDiv.querySelectorAll('*');
                            allElements.forEach(el => {
                                // Limitar tama√±o de elementos con emojis
                                if (el.textContent && /[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|‚úÖ|‚ùå|‚úì|‚úó|üìã|üê≥|‚ò∏Ô∏è/u.test(el.textContent)) {
                                    const computedStyle = window.getComputedStyle(el);
                                    const fontSize = parseFloat(computedStyle.fontSize);
                                    if (fontSize > 24) {
                                        el.style.fontSize = '1em';
                                    }
                                }
                            });
                        }, 0);
                    } else {
                        // Convertir markdown a HTML
                        let html = marked.parse(content.trim());
                        
                        // Corregir rutas de im√°genes relativas
                        // Convertir rutas relativas como images/img.png a rutas relativas al m√≥dulo
                        html = html.replace(/<img[^>]+src="([^"]+)"/g, (match, path) => {
                            // Si la ruta no empieza con http://, https://, o /, hacerla relativa al m√≥dulo
                            if (!path.startsWith('http://') && !path.startsWith('https://') && !path.startsWith('/')) {
                                const newPath = `${module}/${path}`;
                                return match.replace(`src="${path}"`, `src="${newPath}"`);
                            }
                            return match;
                        });
                        
                        slideDiv.innerHTML = html;
                    }
                    
                    container.appendChild(slideDiv);
                    slides.push(slideDiv);
                    
                    // Resaltar sintaxis despu√©s de agregar al DOM
                    setTimeout(() => {
                        Prism.highlightAllUnder(slideDiv);
                    }, 0);
                });

                if (slides.length > 0) {
                    // Resaltar sintaxis en todas las slides
                    slides.forEach(slide => {
                        Prism.highlightAllUnder(slide);
                    });
                    // Verificar si hay hash en la URL para ir a un slide espec√≠fico
                    // Primero verificar sessionStorage (para preservar despu√©s de reload)
                    let hash = sessionStorage.getItem('preserveHash');
                    if (hash) {
                        sessionStorage.removeItem('preserveHash');
                    } else {
                        hash = window.location.hash;
                    }
                    
                    // Determinar slide inicial
                    let initialSlide = 0;
                    if (hash && hash.startsWith('#slide-')) {
                        const slideNum = parseInt(hash.replace('#slide-', ''));
                        if (!isNaN(slideNum) && slideNum >= 0 && slideNum < slides.length) {
                            initialSlide = slideNum;
                        }
                    }
                    
                    // Establecer slide inicial directamente sin usar showSlide para evitar loops
                    currentSlideIndex = initialSlide;
                    
                    // Mostrar slide inicial
                    slides.forEach((slide, i) => {
                        slide.classList.remove('active', 'prev');
                        if (i < initialSlide) {
                            slide.classList.add('prev');
                        } else if (i === initialSlide) {
                            slide.classList.add('active');
                            Prism.highlightAllUnder(slide);
                        }
                    });
                    
                    updateSlideCounter();
                    updateButtons();
                    
                    // Actualizar hash solo si no coincide (evitar actualizaciones innecesarias)
                    const expectedHash = `#slide-${initialSlide}`;
                    if (window.location.hash !== expectedHash && !isUpdatingHash) {
                        try {
                            window.history.replaceState(null, '', window.location.pathname + window.location.search + expectedHash);
                        } catch (e) {
                            // Ignorar errores de throttling
                        }
                    }
                    
                    // Inicializar localStorage DESPU√âS de establecer el slide inicial
                    // Esto previene que el intervalo de sincronizaci√≥n cause loops
                    setTimeout(() => {
                        localStorage.setItem('currentModule', module);
                        localStorage.setItem('currentSlideIndex', initialSlide);
                        lastSlideIndex = initialSlide; // Sincronizar tambi√©n lastSlideIndex
                    }, 100);
                } else {
                    container.innerHTML = '<div class="error"><h1>No se encontraron slides</h1><p>El archivo est√° vac√≠o o no tiene formato v√°lido</p></div>';
                }
            })
            .catch(error => {
                const errorBackUrl = module.startsWith('kubernetes/') ? 'index-kubernetes.html' : 'index.html';
                const container = document.getElementById('slides-container');
                
                // Detectar errores de CORS
                const isCorsError = error.message.includes('CORS') || 
                                   error.message.includes('Failed to fetch') ||
                                   error.message.includes('network') ||
                                   (window.location.protocol === 'file:');
                
                if (isCorsError || window.location.protocol === 'file:') {
                    container.innerHTML = `
                        <div class="error">
                            <h1>‚ö†Ô∏è Error de CORS</h1>
                            <p style="font-size: 1.2em; margin-bottom: 30px;">
                                No se pueden cargar archivos usando el protocolo <code>file://</code>
                            </p>
                            <div style="background: rgba(102, 126, 234, 0.1); padding: 20px; border-radius: 10px; max-width: 600px; text-align: left; margin: 20px 0;">
                                <h3 style="color: #667eea; margin-bottom: 15px;">üìã Soluci√≥n: Usa un servidor HTTP local</h3>
                                <p style="margin-bottom: 15px;">Ejecuta uno de estos comandos en la terminal:</p>
                                <pre style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 5px; overflow-x: auto; margin: 10px 0;"><code style="color: #a8b5ff;"># Desde la ra√≠z del proyecto:
npm run serve

# O si est√°s en la carpeta dist:
cd dist && npx http-server -p 8000 --cors</code></pre>
                                <p style="margin-top: 15px; font-size: 0.9em; color: #aaa;">
                                    Luego abre: <code style="color: #667eea;">http://localhost:8000/viewer.html?module=${module}</code>
                                </p>
                            </div>
                            <a href="${errorBackUrl}" class="back-button" style="margin-top: 20px;">Volver al inicio</a>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="error">
                            <h1>Error al cargar slides</h1>
                            <p>${error.message}</p>
                            <p style="font-size: 0.9em; color: #888;">Aseg√∫rate de que el archivo slides.html o slides.md existe en ${module}/</p>
                            <a href="${errorBackUrl}" id="errorBackButton" class="back-button">Volver al inicio</a>
                        </div>
                    `;
                }
            });

        let isUpdatingHash = false; // Prevenir actualizaciones m√∫ltiples del hash
        let hashUpdateTimeout = null;
        
        function showSlide(index) {
            if (index < 0 || index >= slides.length) return;
            if (index === currentSlideIndex && slides[index] && slides[index].classList.contains('active')) {
                // Si ya est√° mostrando este slide, no hacer nada para evitar loops
                return;
            }
            
            slides.forEach((slide, i) => {
                slide.classList.remove('active', 'prev');
                if (i < index) {
                    slide.classList.add('prev');
                } else if (i === index) {
                    slide.classList.add('active');
                    // Resaltar sintaxis cuando se muestra la slide
                    Prism.highlightAllUnder(slide);
                }
            });
            
            currentSlideIndex = index;
            lastSlideIndex = index; // Actualizar tambi√©n lastSlideIndex para evitar sincronizaciones innecesarias
            updateSlideCounter();
            updateButtons();
            
            // Actualizar hash en la URL (con debounce para evitar throttling)
            const newHash = `#slide-${index}`;
            if (window.location.hash !== newHash && !isUpdatingHash) {
                // Limpiar timeout anterior si existe
                if (hashUpdateTimeout) {
                    clearTimeout(hashUpdateTimeout);
                }
                
                // Usar debounce para evitar m√∫ltiples actualizaciones
                isUpdatingHash = true;
                hashUpdateTimeout = setTimeout(() => {
                    try {
                        window.history.replaceState(null, '', window.location.pathname + window.location.search + newHash);
                    } catch (e) {
                        // Ignorar errores de throttling
                        console.log('Hash update throttled, skipping...');
                    }
                    isUpdatingHash = false;
                    hashUpdateTimeout = null;
                }, 100); // Debounce de 100ms
            }
            
            // Sincronizar con notas de orador (solo si est√° inicializado para evitar loops)
            if (isInitialized) {
                localStorage.setItem('currentSlideIndex', index);
                localStorage.setItem('currentModule', module);
            }
            
            // Disparar evento personalizado para mejor sincronizaci√≥n
            window.dispatchEvent(new CustomEvent('slideChanged', { detail: { index } }));
        }

        function nextSlide() {
            if (currentSlideIndex < slides.length - 1) {
                showSlide(currentSlideIndex + 1);
            }
        }

        function previousSlide() {
            if (currentSlideIndex > 0) {
                showSlide(currentSlideIndex - 1);
            }
        }

        function updateSlideCounter() {
            document.getElementById('currentSlide').textContent = currentSlideIndex + 1;
            document.getElementById('totalSlides').textContent = slides.length;
        }

        function updateButtons() {
            document.getElementById('prevBtn').disabled = currentSlideIndex === 0;
            document.getElementById('nextBtn').disabled = currentSlideIndex === slides.length - 1;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Error al entrar en pantalla completa:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Navegaci√≥n con teclado
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                previousSlide();
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleFullscreen();
            } else if (e.key === 'Home') {
                e.preventDefault();
                showSlide(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                showSlide(slides.length - 1);
            }
        });

        // Navegaci√≥n con scroll deshabilitada - solo botones y teclado
        // (Comentado para evitar navegaci√≥n accidental con el mouse)
        // let scrollTimeout;
        // document.addEventListener('wheel', (e) => {
        //     e.preventDefault();
        //     clearTimeout(scrollTimeout);
        //     scrollTimeout = setTimeout(() => {
        //         if (e.deltaY > 0) {
        //             nextSlide();
        //         } else {
        //             previousSlide();
        //         }
        //     }, 100);
        // }, { passive: false });

        // Escuchar cambios en localStorage (para sincronizaci√≥n desde notas en otras ventanas)
        window.addEventListener('storage', (e) => {
            if (e.key === 'currentSlideIndex') {
                const index = parseInt(e.newValue);
                if (index >= 0 && index < slides.length && index !== currentSlideIndex) {
                    showSlide(index);
                }
            }
            if (e.key === 'currentModule') {
                const newModule = e.newValue;
                if (newModule !== module) {
                    window.location.href = `viewer.html?module=${newModule}`;
                }
            }
        });

        // Tambi√©n escuchar cambios en localStorage de la misma ventana (para sincronizaci√≥n desde notas)
        // Monitorear cambios en localStorage cada 800ms (aumentado para evitar loops)
        let lastSlideIndex = currentSlideIndex;
        let isSyncing = false; // Prevenir loops de sincronizaci√≥n
        let isInitialized = false; // Prevenir sincronizaci√≥n durante inicializaci√≥n
        let syncInterval = null;
        
        // Iniciar sincronizaci√≥n solo despu√©s de que la p√°gina est√© completamente cargada
        setTimeout(() => {
            isInitialized = true;
            syncInterval = setInterval(() => {
                if (!isInitialized || isSyncing || isUpdatingHash) return; // No sincronizar si no est√° inicializado o ya se est√° actualizando
                
                const storedIndex = localStorage.getItem('currentSlideIndex');
                const storedModule = localStorage.getItem('currentModule');
                
                // Solo sincronizar si el m√≥dulo coincide
                if (storedModule !== module) return;
                
                if (storedIndex !== null) {
                    const index = parseInt(storedIndex);
                    // Solo sincronizar si el √≠ndice realmente cambi√≥ y es diferente al actual
                    if (index !== lastSlideIndex && index !== currentSlideIndex && index >= 0 && index < slides.length) {
                        isSyncing = true;
                        lastSlideIndex = index;
                        currentSlideIndex = index; // Actualizar antes de mostrar para evitar loops
                        showSlide(index);
                        setTimeout(() => { isSyncing = false; }, 300);
                    } else if (index === currentSlideIndex) {
                        // Si coincide, actualizar lastSlideIndex para evitar futuras sincronizaciones innecesarias
                        lastSlideIndex = index;
                    }
                }
            }, 800);
        }, 500); // Esperar 500ms despu√©s de la carga inicial
        
        // Limpiar intervalo al cerrar
        window.addEventListener('beforeunload', () => {
            if (syncInterval) {
                clearInterval(syncInterval);
            }
        });

        // Escuchar mensajes de otras ventanas (postMessage)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'slideChanged') {
                const index = event.data.index;
                if (index >= 0 && index < slides.length && index !== currentSlideIndex) {
                    showSlide(index);
                }
            }
        });

        // Live reload: monitorear cambios en el archivo de slides
        let lastContentHash = null;
        let reloadCheckInterval = null;
        let isReloading = false; // Prevenir loops de recarga
        
        function checkForUpdates() {
            // Prevenir m√∫ltiples recargas simult√°neas
            if (isReloading) {
                return;
            }
            
            // Intentar cargar slides.html primero, luego slides.md
            return fetch(`${module}/slides.html?t=${Date.now()}`, { cache: 'no-store' })
                .then(response => {
                    if (response.ok) {
                        return response.text();
                    }
                    // Si no existe HTML, intentar con MD
                    return fetch(`${module}/slides.md?t=${Date.now()}`, { cache: 'no-store' })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('No se pudo obtener el archivo');
                            }
                            return response.text();
                        });
                })
                .then(content => {
                    // Calcular hash m√°s preciso del contenido
                    const hash = content.length + '-' + 
                                 content.substring(0, 500).replace(/\s/g, '').length + '-' +
                                 content.split('---').length;
                    if (lastContentHash && hash !== lastContentHash && !isReloading) {
                        isReloading = true; // Marcar que estamos recargando
                        console.log('üîÑ Cambios detectados, recargando slides...');
                        // Mostrar notificaci√≥n visual
                        const notification = document.createElement('div');
                        notification.style.cssText = 'position:fixed;top:20px;right:20px;background:#667eea;color:white;padding:15px 25px;border-radius:8px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
                        notification.textContent = 'üîÑ Recargando slides...';
                        document.body.appendChild(notification);
                        
                        // Preservar el slide actual en el hash al recargar
                        const currentHash = window.location.hash;
                        if (currentHash) {
                            sessionStorage.setItem('preserveHash', currentHash);
                        }
                        
                        // Limpiar intervalo antes de recargar
                        if (reloadCheckInterval) {
                            clearInterval(reloadCheckInterval);
                            reloadCheckInterval = null;
                        }
                        
                        // Forzar recarga sin cach√© (usar location.reload para evitar loops)
                        setTimeout(() => {
                            window.location.reload();
                        }, 500);
                    }
                    lastContentHash = hash;
                })
                .catch(err => {
                    // Ignorar errores silenciosamente
                });
        }
        
        // Iniciar live reload solo si estamos en modo desarrollo (par√°metro ?dev=true)
        if (urlParams.get('dev') === 'true') {
            console.log('üîÑ Live reload activado');
            // Verificar cada 3 segundos (aumentado para reducir carga)
            reloadCheckInterval = setInterval(checkForUpdates, 3000);
            // Verificar tambi√©n cuando la ventana recupera el foco (solo si no est√° recargando)
            window.addEventListener('focus', () => {
                if (!isReloading) {
                    checkForUpdates();
                }
            });
        }
        
        // Limpiar intervalos y timeouts al cerrar
        window.addEventListener('beforeunload', () => {
            if (reloadCheckInterval) {
                clearInterval(reloadCheckInterval);
            }
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            if (hashUpdateTimeout) {
                clearTimeout(hashUpdateTimeout);
            }
        });
    </script>
</body>
</html>
